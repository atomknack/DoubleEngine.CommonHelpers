//     This code was generated by a tool. Changes will be lost if the code is regenerated.

using System;

namespace CollectionLike;

public static partial class CollectionLike_Extension
{
    public static int Count<T>(this Span<T> source, Predicate<T> predicate)//, int startSearchFrom = 0)
    {
#if DEBUG || TESTING
        if (predicate == null)
            throw new ArgumentNullException("predicate should not be null");
#endif
        int count = 0;
        for (int i = 0; i < source.Length; i++)//for (int i = startSearchFrom; i < source.Length; i++)
            if (predicate(source[i])) ++count;
        return count;
        //throw new Exception("No element found to return IndexOf");
    }
    public static int Count<T>(this Span<T> items, T target) where T : IEquatable<T>
    {
        int count = 0;
        for (int i = 0; i < items.Length; ++i)
            if (target.Equals(items[i]))
                ++count;
        return count;
    }
    public static int Count<T>(this ReadOnlySpan<T> source, Predicate<T> predicate)//, int startSearchFrom = 0)
    {
#if DEBUG || TESTING
        if (predicate == null)
            throw new ArgumentNullException("predicate should not be null");
#endif
        int count = 0;
        for (int i = 0; i < source.Length; i++)//for (int i = startSearchFrom; i < source.Length; i++)
            if (predicate(source[i])) ++count;
        return count;
        //throw new Exception("No element found to return IndexOf");
    }
    public static int Count<T>(this ReadOnlySpan<T> items, T target) where T : IEquatable<T>
    {
        int count = 0;
        for (int i = 0; i < items.Length; ++i)
            if (target.Equals(items[i]))
                ++count;
        return count;
    }
}
